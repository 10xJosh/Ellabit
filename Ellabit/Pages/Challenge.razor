@page "/challenge/{ChallengeId:int?}"
@using DynamicCode
@using System.Reflection
@using Ellabit.Challenges
@inject IJSRuntime JS
<PageTitle>Ellabit - Return the Sum of Two Numbers</PageTitle>

<MudTabs 
    Elevation="4" 
    Rounded="true" 
    Centered="true" 
    Color="@Color.Primary"     
    ActivePanelIndexChanged="OnTabChanged"
    >
    <MudTabPanel Text="Instructions">
        @((MarkupString)(_unloadable?.Context?.Challenge?.Description ?? ""))
    </MudTabPanel>
    <MudTabPanel Text="Code">
        <div id="editor" style="width:fit-content(800px);height:600px;border:1px solid grey"></div>
    </MudTabPanel>
    <MudTabPanel Text="Tests">
         
            <MudButton Variant="Variant.Filled" Color="Color.Primary" @onclick="OnExecuteTests">Execute Tests</MudButton>

            <p>
            @((MarkupString)(testResults ?? ""))
            </p>
        
    </MudTabPanel>
</MudTabs>

@code {
    [Parameter]
    public int? ChallengeId { get; set; }

    [Inject]
    public SimpleUnloadable? _unloadable { get; set; }
    [Inject]
    public IServiceProvider? ServiceProvider{ get; set; }
    [Inject] 
    private IDialogService? DialogService { get; set; }
    [Inject]
    private Challenges? Challenges { get; set; }
    bool loaded = false;
    int prevTabIndex = -1;
    string? code;
    string testResults = "";
    protected override void OnInitialized()
    {
        base.OnInitialized();
        SetChallenge();
    }
    public void SetChallenge()
    {
        if (_unloadable?.Context != null && Challenges != null)
        {            
            _unloadable.Context.Challenge = Challenges[ChallengeId ?? 1];
            code = _unloadable.Context.Challenge.Code;
            StateHasChanged();
        }
    }
    /// <summary>
    /// Since the state of the editor is lost every time we switch tabs we have to 
    /// - Iniialize editory every time we go into the code tab
    /// - When leaving code tab save text in editor
    /// </summary>
    /// <param name="tabIndex"></param>
    public async void OnTabChanged(int tabIndex)
    {
        if (tabIndex != 1)
        {
            await TabChanged_ClearEditor();
        }
        if (tabIndex == 1)
        {
            await TabChanged_LoadEditor();
        }
        prevTabIndex = tabIndex;
    }
    public async Task TabChanged_ClearEditor()
    {
        if (loaded && _unloadable?.Context?.Challenge != null && prevTabIndex == 1) 
        {
            code = await BlazacoJSInterop.GetValue(JS, "editor");
            _unloadable.Context.Challenge.Code = code;
        }
        await BlazacoJSInterop.ClearEditors(JS);
    }
    public async Task TabChanged_LoadEditor()
    {
        StateHasChanged();
        await Task.Delay(1);
        await BlazacoJSInterop.InitializeEditor(JS, "editor");
        if (_unloadable?.Context?.Challenge?.Code != null)
        {
            await BlazacoJSInterop.SetValue(JS, "editor", code ?? "");
        }
        loaded = true;
        await Task.Delay(1);        
    }


    public async void OnExecuteTests()
    {
        ClearChallengeCache();
        testResults = "";
        StateHasChanged();
        await ExecuteTests();
    }
    private async Task ExecuteTests()
    {
        testResults = "";

        if (_unloadable?.Context?.Challenge?.Tests == null)
        {
            testResults += "\nCode didn't compile";
            return;
        }

        try
        {
            int testNum = 1;
            foreach (var test in _unloadable.Context.Challenge.Tests)
            {
                try
                {                    
                    var testResult = await _unloadable.Context.RunTest(test);
                    testResults += $"<br/>Test {testNum} " + (testResult.pass ? "Pass" : ("FAILED " + testResult.message));
                } catch (Exception ex)
                {
                    if (ex is IOException) {
                        testResults += $"<br/>FAILED " + ex.Message;
                        return;
                    } 
                    testResults += $"<br/>Test {testNum} " + "\n FAILED " + ex.Message;
                }
                testNum++;
            }

        } catch (Exception ex)
        {
            if (DialogService != null)
            {
                await DialogService.ShowMessageBox(
                    "Error", 
                    ex.Message, 
                    yesText:"OK");
                StateHasChanged();
            }

            testResults += "\nUnexpected Error " + ex.Message;
            return;
        }
        finally
        {
            StateHasChanged();
        }
    }

    public void ClearChallengeCache()
    {

        if (_unloadable?.Context?.Challenge == null)
        {
            return;
        }
        _unloadable.ClearCache();
        SetChallenge();
        _unloadable.Context.Challenge.Code = code;        
    }
}

